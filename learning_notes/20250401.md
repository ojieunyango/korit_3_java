# 빌더패턴(builder pattern)

## 정의
객체의 생성 과정에서 복잡한 생성자를 대신하여 객체를 단계적으로 생성할수있도록 도와주는 디자인 패턴. GOF(Gang of Four) 
디자인 패턴 중하나로 객체 생성시 가독성과 유연성을 제공하는것이 목표

## 특징
1. 객체를 생성하는 여러개의 필드를 명시적으로 관리할수있음
2. 불필요한 생성자 오버로딩을 줄여 가독성을 높임
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성

## 빌더 패턴이 생기게된 원인
1. 복잡한 생성자 문제
- 객체의 필드가 많아질수록 생성자의 파라미터 수도로 늘어남
2. 생성자 오버로딩 문제
- 생성자에 필요한 조합이 다를 경우 수많은 생성자를 만들어야함
- 유지보수에 악영향/필드하나 추가하면 생성자를 다 뜯어고쳐야함
-> 저희 RemoteController 할때 필드하나 추가해서 생성자와 main 다 뜯어고쳐야 프로그램이 돌아갔떤 부분을 생각하면 됨
 
3. 가독성과 유지보수 문제 
- 코드를 작성하고 읽는 입장에서는 객체를 생성할때 어떤값이 어떤 필드에 해당하는지가 명확하지않아서 실수를 유발할수있음

# 제너릭(Generic)
## 개념 및 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타입 매개변수(type parameter)
- 클래스나 메서드에서 사용할 실제 타입을 대신하여 사용하는 매개변수
- 일반적으로 알파벳 대문자 하나로 표기함
  1. T(Type): 일반적으로 클래스 타입을 나타낼때 사용
  2. E(Element): 컬렉션의 요소를 나타낼때 사용
  3. K(Key): Map의 Key를 나타낼때 사용
  4. V(Value): Map의 value 또는 제네릭 타입의 반환값으로 사용

### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할수 있어 코드의 재사용성을 높이고 중복을 줄입니다.

### 타입 안정성 (Type Safety)
- 컴파일 시점에 타입 체크를 할수있어 프로그램의 안전성을 높이고 명시적인 형변화을 줄임

# Java 제네릭 와일드 카드 (generic wildcard)

## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수할 수 있도록 하는 문법. 다양한 타입에 재사용이 가능
````java
class Box<T>{
     private T value;
     private void set(T value){
          this.value = value;
}
public T get(){return value;}
}
````

이렇게 사용할때 Box<Integer>/Box<String> 같은 식으로 value 의 자료형을 하나로 고정하지않고 사용가능함

## 와일드 카드
- 이상의 제네릭 타입을 사용할때 구체적이 타입을 명시하지않고도 범용적으롱 처리하고 싶을 때 사용하는 "?" 기호
  
타입을 명확하게 지정하지 않고, 어떤 타입이든 허용할 수 있게 해주는 기능입니다.
주로 ? (물음표) 기호로 사용됩니다.


? extends T는 T의 하위 타입을 나타냅니다.
즉, T와 T의 서브클래스들이 해당 타입으로 들어올 수 있음을 의미합니다.
예시: List<? extends Number>는 Number와 그 하위 클래스(Integer, Double 등)을 포함하는 리스트입니다.

```java
import java.util.ArrayList;

List<?> exampliList = new ArrayList<>(String);
```
즉, <?>는 무슨 타입이든 가능하다는 뜻

### 종류
1. <?>: 모든 타입허용(unbounded wildcard)
2. <? extends T>: T 또는  T의 서브타입(upper bounded wildcard)
3. <?superT> : T 또는 T의 슈퍼 타입(lower bounded wildcard)
- 쓰기 전용, 제한된 타입으로 넣을때

# Collection
- 여러 객체를 모아놓은 것을 의미함.

## 종류
1. List: 순서가 있는 데이터의 집합으로 중복된 요소를 허락함
- ArrayList: 배열기반의 리스트, 요소접근 속도가 빠름
- LinkedList: 연결 리스트의 리스트, 삽입/ 삭제 속도가 빠름

2. Set: 중복을 허용하지앟는 데이터들의 집합
- HashSet: 해시테이블 기반의 집합, 요소의 순서를 보장 안함 
- TreeSet: 이진(binary)검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨

3. Map: 키(Key)와 값(Value)의 쌍으로 이루어진 데이터들의 집합
- HashMap: 해시 테이블 기반의 맵, 키의 순서를 보장 안함
- TreeMap: 이진 검색트리 기반의 맵, 키가 정렬된 상태로 유지

## 요약

1. List ( ArrayList, LinkedList, Vector)
 순서가 있는 데이터를 저장하고, 중복 허용. 인덱스를 사용하여 접근할 수 있습니다.

2. Set(HashSet, LinkedHashSet, TreeSet)
   순서가 없는 데이터를 저장하고, 중복을 허용하지 않음.

3. Map(HashMap, TreeMap, LinkedHashMap)
   키-값 쌍으로 데이터를 저장. 키는 중복되지 않음, 값은 중복 가능.

4. Queue(LinkedList, PriorityQueue)
   선입선출(FIFO) 방식으로 데이터를 처리하는 컬렉션입니다.
주로 우선순위 큐나 일반 큐로 데이터를 처리할 때 사용됩니다.

5. Stack
   후입선출(LIFO) 방식으로 데이터를 처리하는 컬렉션입니다.
예를 들어, 데이터를 쌓았다가 나중에 하나씩 꺼내는 방식입니다.


7. Iterator
   컬렉션의 데이터를 순차적으로 접근할 때 사용하는 인터페이스입니다.






